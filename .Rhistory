patient_id,
age,
sex,
ethnicity_combined,
imd_Q5,
region,
jcvi_group,
rural_urban_group,
prior_covid_infection,
prior_tests_cat,
multimorb,
learndis,
sev_mental,
vax12_type,
vax2_to_startdate =  study_dates$studystart_date - vax2_date,
vax2_week,
vax3_date,
vax3_type,
)
logoutput_datasize(data_baseline)
data_matched <-
read_rds(here("output", "models", "seqtrialcox", treatment, outcome, "match_data_matched.rds")) %>%
mutate(
treated_patient_id = paste0(treated, "_", patient_id),
)
data_tte <- read_rds(here("output", "models", "seqtrialcox", treatment, outcome, "match_data_tte.rds"))
if(removeobjects) rm(data_cohort)
# one row per vaccination or outcome or censoring event ----
## person-time dataset of vaccination status + outcome
data_events <-
data_tte %>%
select(patient_id) %>%
tmerge(
data1 = .,
data2 = data_tte,
id = patient_id,
tstart = 0L,
tstop = tte_stop,
treatment_event = event(tte_treatment),
treatment_status = tdc(tte_treatment),
outcome_event = event(tte_outcome),
censor_event = event(tte_censor)
) #%>%
# tmerge(
#   data1 = .,
#   data2 = data_tte,
#   id = patient_id,
#   vax3_event = event(tte_vax3, vax3_type),
#   vax3_status = tdc(tte_vax3, vax3_type),
#   options= list(tdcstart="")
# ) %>%
# mutate(
#   across(where(is.numeric), as.integer),
#   vax3_event=factor(vax3_event, levels=c("", "pfizer", "az", "moderna")),
#   vax3_status=factor(vax3_status, levels=c("", "pfizer", "az", "moderna"))
# )
logoutput_datasize(data_events)
## one row per time-varying covariate value change ----
data_timevarying <- local({
data_join <-
data_tte %>%
select(patient_id, day1_date, censor_date, tte_stop)
data_positive_test <-
read_rds(here("output", "data", "data_long_positive_test_dates.rds")) %>%
inner_join(data_join, ., by =c("patient_id")) %>%
mutate(
tte = tte(day1_date, date, censor_date, na.censor=TRUE),
)
data_admitted_unplanned <-
read_rds(here("output", "data", "data_long_admitted_unplanned_dates.rds")) %>%
pivot_longer(
cols=c(admitted_date, discharged_date),
names_to="status",
values_to="date",
values_drop_na = TRUE
) %>%
inner_join(data_join, ., by =c("patient_id")) %>%
mutate(
tte = tte(day1_date, date, censor_date, na.censor=TRUE) %>% as.integer(),
admittedunplanned_status = if_else(status=="admitted_date", 1L, 0L)
)
data_admitted_planned <-
read_rds(here("output", "data", "data_long_admitted_planned_dates.rds")) %>%
pivot_longer(
cols=c(admitted_date, discharged_date),
names_to="status",
values_to="date",
values_drop_na = TRUE
) %>%
inner_join(data_join, ., by =c("patient_id")) %>%
mutate(
tte = tte(day1_date, date, censor_date, na.censor=TRUE) %>% as.integer(),
admittedplanned_status = if_else(status=="admitted_date", 1L, 0L)
)
data_timevarying <- data_tte %>%
arrange(patient_id) %>%
select(patient_id) %>%
tmerge(
data1 = .,
data2 = data_tte,
id = patient_id,
tstart = -1000L,
tstop = tte_stop,
treatment_status = tdc(tte_treatment)
) %>%
tmerge(
data1 = .,
data2 = data_positive_test,
id = patient_id,
postest_mostrecent = tdc(tte,tte)
) %>%
tmerge(
data1 = .,
data2 = data_admitted_unplanned,
id = patient_id,
admittedunplanned_status = tdc(tte, admittedunplanned_status),
options = list(tdcstart = 0L)
) %>%
tmerge(
data1 = .,
data2 = data_admitted_planned,
id = patient_id,
admittedplanned_status = tdc(tte, admittedplanned_status),
options = list(tdcstart = 0L)
) %>%
mutate(id=NULL) # remove id column if created by tmerge (depedning on version of survival package)
data_timevarying
})
logoutput_datasize(data_timevarying)
## create analysis dataset - one row per trial per arm per patient per follow-up week ----
data_seqtrialcox <- local({
data_st0 <-
tmerge(
data1 = data_matched,
data2 = data_matched,
id = treated_patient_id,
tstart = tte_recruitment,
tstop = tte_stop
) %>%
mutate(id=NULL) %>% # remove id column if created by tmerge (depending on version of survival package)
# add time-varying info as at recruitment date (= tte_trial)
left_join(
data_timevarying %>% rename(tstart2 = tstart, tstop2 = tstop),
by = c("patient_id")
) %>%
filter(
tstart < tstop2,
tstart >= tstart2
) %>%
select(-tstart2, -tstop2) %>%
# add time-non-varying info
left_join(
data_baseline %>% select(-all_of(matching_variables)),
by=c("patient_id")
) %>%
# remaining variables that combine both
mutate(
vax2_dayssince = vax2_to_startdate+tte_recruitment,
postest_dayssince = tstart - postest_mostrecent,
postest_status = fct_case_when(
is.na(postest_dayssince) & !prior_covid_infection ~ "No previous infection",
between(postest_dayssince, 0, 21) ~ "Positive test <= 21 days ago",
postest_dayssince>21 | prior_covid_infection ~ "Positive test > 21 days ago",
TRUE ~ NA_character_
),
)
## create treatment timescale variables ----
# one row per patient per post-recruitment split time
fup_split <-
data_matched %>%
uncount(weights = length(postbaselinecuts)-1, .id="period_id") %>%
mutate(
fup_time = postbaselinecuts[period_id],
fup_period = timesince_cut(fup_time, postbaselinecuts-1),
tte_fup = tte_recruitment + fup_time
) %>%
droplevels() %>%
select(
patient_id, treated, treated_patient_id, period_id, tte_fup, fup_time,
fup_period
)
# add post-recruitment periods to data
data_st <-
# re-initialise tmerge object
tmerge(
data1 = data_st0,
data2 = data_matched,
id = treated_patient_id,
tstart = tte_recruitment,
tstop = tte_stop,
ind_outcome = event(tte_outcome)
) %>%
# add post-recruitment periods
tmerge(
data1 = .,
data2 = fup_split,
id = treated_patient_id,
fup_period = tdc(tte_fup, fup_period),
treated_period = tdc(tte_fup, period_id)
) %>%
mutate(
id = NULL,
# time-zero is recruitment day
tstart = tstart - tte_recruitment,
tstop = tstop - tte_recruitment
) %>%
fastDummies::dummy_cols(select_columns = c("treated_period"), remove_selected_columns = TRUE) %>%
mutate(
across(
starts_with("treated_period_"),
~if_else(treated==1, .x, 0L)
)
)
data_st
})
logoutput_datasize(data_seqtrialcox)
# # # # # # # # # # # # # # # # # # # # #
# This script:
# imports processed data
# fits some Cox models with time-varying effects
# The script must be accompanied by one argument:
# `outcome` - the dependent variable in the regression model
# # # # # # # # # # # # # # # # # # # # #
# Preliminaries ----
# import command-line arguments ----
args <- commandArgs(trailingOnly=TRUE)
if(length(args)==0){
# use for interactive testing
removeobjects <- FALSE
treatment <- "pfizer"
outcome <- "postest"
subgroup <- ""
} else {
removeobjects <- TRUE
treatment <- args[[1]]
outcome <- args[[2]]
}
## Import libraries ----
library('tidyverse')
library('here')
library('glue')
library('survival')
## Import custom user functions from lib
source(here("lib", "functions", "utility.R"))
source(here("lib", "functions", "survival.R"))
source(here("lib", "functions", "redaction.R"))
postbaselinecuts <- read_rds(here("lib", "design", "postbaselinecuts.rds"))
matching_variables <- read_rds(here("lib", "design", "matching_variables.rds"))
if(Sys.getenv("OPENSAFELY_BACKEND") %in% c("", "expectations")){
recruitment_period_cutoff <- 0.1
} else{
recruitment_period_cutoff <- read_rds(here("lib", "design", "recruitment_period_cutoff.rds"))
}
# create output directories ----
output_dir <- here("output", "models", "seqtrialcox", treatment, outcome)
fs::dir_create(output_dir)
## create special log file ----
cat(glue("## script info for {outcome} ##"), "  \n", file = fs::path(output_dir, glue("model_log.txt")), append = FALSE)
## functions to pass additional log info to seperate file
logoutput <- function(...){
cat(..., file = fs::path(output_dir, glue("model_log.txt")), sep = "\n  ", append = TRUE)
cat("\n", file = fs::path(output_dir, glue("model_log.txt")), sep = "\n  ", append = TRUE)
}
logoutput_datasize <- function(x){
nm <- deparse(substitute(x))
logoutput(
glue(nm, " data size = ", nrow(x)),
glue(nm, " memory usage = ", format(object.size(x), units="GB", standard="SI", digits=3L))
)
}
logoutput_table <- function(x){
capture.output(
x,
file=fs::path(output_dir, glue("model_log.txt")),
append=TRUE
)
cat("\n", file = fs::path(output_dir, glue("model_log.txt")), sep = "\n  ", append = TRUE)
}
## import globally defined study dates and convert to "Date"
study_dates <-
jsonlite::read_json(path=here("lib", "design", "study-dates.json")) %>%
map(as.Date)
## import metadata ----
events <- read_rds(here("lib", "design", "event-variables.rds"))
outcome_var <- events$event_var[events$event==outcome]
var_labels <- read_rds(here("lib", "design", "variable-labels.rds"))
# compose modelling dataset ----
## one pow per patient ----
data_cohort <- read_rds(here("output", "data", "data_cohort.rds"))
logoutput_datasize(data_cohort)
## baseline variables ----
data_baseline <-
data_cohort %>%
transmute(
patient_id,
age,
sex,
ethnicity_combined,
imd_Q5,
region,
jcvi_group,
rural_urban_group,
prior_covid_infection,
prior_tests_cat,
multimorb,
learndis,
sev_mental,
vax12_type,
vax2_to_startdate =  study_dates$studystart_date - vax2_date,
vax2_week,
vax3_date,
vax3_type,
)
logoutput_datasize(data_baseline)
data_matched <-
read_rds(here("output", "models", "seqtrialcox", treatment, outcome, "match_data_matched.rds")) %>%
mutate(
treated_patient_id = paste0(treated, "_", patient_id),
)
data_tte <- read_rds(here("output", "models", "seqtrialcox", treatment, outcome, "match_data_tte.rds"))
if(removeobjects) rm(data_cohort)
# one row per vaccination or outcome or censoring event ----
## person-time dataset of vaccination status + outcome
data_events <-
data_tte %>%
select(patient_id) %>%
tmerge(
data1 = .,
data2 = data_tte,
id = patient_id,
tstart = 0L,
tstop = tte_stop,
treatment_event = event(tte_treatment),
treatment_status = tdc(tte_treatment),
outcome_event = event(tte_outcome),
censor_event = event(tte_censor)
) #%>%
# tmerge(
#   data1 = .,
#   data2 = data_tte,
#   id = patient_id,
#   vax3_event = event(tte_vax3, vax3_type),
#   vax3_status = tdc(tte_vax3, vax3_type),
#   options= list(tdcstart="")
# ) %>%
# mutate(
#   across(where(is.numeric), as.integer),
#   vax3_event=factor(vax3_event, levels=c("", "pfizer", "az", "moderna")),
#   vax3_status=factor(vax3_status, levels=c("", "pfizer", "az", "moderna"))
# )
logoutput_datasize(data_events)
## one row per time-varying covariate value change ----
data_timevarying <- local({
data_join <-
data_tte %>%
select(patient_id, day1_date, censor_date, tte_stop)
data_positive_test <-
read_rds(here("output", "data", "data_long_positive_test_dates.rds")) %>%
inner_join(data_join, ., by =c("patient_id")) %>%
mutate(
tte = tte(day1_date, date, censor_date, na.censor=TRUE),
)
data_admitted_unplanned <-
read_rds(here("output", "data", "data_long_admitted_unplanned_dates.rds")) %>%
pivot_longer(
cols=c(admitted_date, discharged_date),
names_to="status",
values_to="date",
values_drop_na = TRUE
) %>%
inner_join(data_join, ., by =c("patient_id")) %>%
mutate(
tte = tte(day1_date, date, censor_date, na.censor=TRUE) %>% as.integer(),
admittedunplanned_status = if_else(status=="admitted_date", 1L, 0L)
)
data_admitted_planned <-
read_rds(here("output", "data", "data_long_admitted_planned_dates.rds")) %>%
pivot_longer(
cols=c(admitted_date, discharged_date),
names_to="status",
values_to="date",
values_drop_na = TRUE
) %>%
inner_join(data_join, ., by =c("patient_id")) %>%
mutate(
tte = tte(day1_date, date, censor_date, na.censor=TRUE) %>% as.integer(),
admittedplanned_status = if_else(status=="admitted_date", 1L, 0L)
)
data_timevarying <- data_tte %>%
arrange(patient_id) %>%
select(patient_id) %>%
tmerge(
data1 = .,
data2 = data_tte,
id = patient_id,
tstart = -1000L,
tstop = tte_stop,
treatment_status = tdc(tte_treatment)
) %>%
tmerge(
data1 = .,
data2 = data_positive_test,
id = patient_id,
postest_mostrecent = tdc(tte,tte)
) %>%
tmerge(
data1 = .,
data2 = data_admitted_unplanned,
id = patient_id,
admittedunplanned_status = tdc(tte, admittedunplanned_status),
options = list(tdcstart = 0L)
) %>%
tmerge(
data1 = .,
data2 = data_admitted_planned,
id = patient_id,
admittedplanned_status = tdc(tte, admittedplanned_status),
options = list(tdcstart = 0L)
) %>%
mutate(id=NULL) # remove id column if created by tmerge (depedning on version of survival package)
data_timevarying
})
logoutput_datasize(data_timevarying)
## create analysis dataset - one row per trial per arm per patient per follow-up week ----
data_seqtrialcox <- local({
data_st0 <-
tmerge(
data1 = data_matched,
data2 = data_matched,
id = treated_patient_id,
tstart = tte_recruitment,
tstop = tte_stop
) %>%
mutate(id=NULL) %>% # remove id column if created by tmerge (depending on version of survival package)
# add time-varying info as at recruitment date (= tte_trial)
left_join(
data_timevarying %>% rename(tstart2 = tstart, tstop2 = tstop),
by = c("patient_id")
) %>%
filter(
tstart < tstop2,
tstart >= tstart2
) %>%
select(-tstart2, -tstop2) %>%
# add time-non-varying info
left_join(
data_baseline %>% select(-all_of(matching_variables)),
by=c("patient_id")
) %>%
# remaining variables that combine both
mutate(
vax2_dayssince = vax2_to_startdate+tte_recruitment,
postest_dayssince = tstart - postest_mostrecent,
postest_status = fct_case_when(
is.na(postest_dayssince) & !prior_covid_infection ~ "No previous infection",
between(postest_dayssince, 0, 21) ~ "Positive test <= 21 days ago",
postest_dayssince>21 | prior_covid_infection ~ "Positive test > 21 days ago",
TRUE ~ NA_character_
),
)
## create treatment timescale variables ----
# one row per patient per post-recruitment split time
fup_split <-
data_matched %>%
uncount(weights = length(postbaselinecuts)-1, .id="period_id") %>%
mutate(
fup_time = postbaselinecuts[period_id],
fup_period = timesince_cut(fup_time, postbaselinecuts-1),
tte_fup = tte_recruitment + fup_time
) %>%
droplevels() %>%
select(
patient_id, treated, treated_patient_id, period_id, tte_fup, fup_time,
fup_period
)
# add post-recruitment periods to data
data_st <-
# re-initialise tmerge object
tmerge(
data1 = data_st0,
data2 = data_matched,
id = treated_patient_id,
# tstart = tte_recruitment,
# tstop = tte_stop,
ind_outcome = event(tte_outcome)
) %>%
# add post-recruitment periods
tmerge(
data1 = .,
data2 = fup_split,
id = treated_patient_id,
fup_period = tdc(tte_fup, fup_period),
treated_period = tdc(tte_fup, period_id)
) %>%
mutate(
id = NULL,
# time-zero is recruitment day
tstart = tstart - tte_recruitment,
tstop = tstop - tte_recruitment
) %>%
fastDummies::dummy_cols(select_columns = c("treated_period"), remove_selected_columns = TRUE) %>%
mutate(
across(
starts_with("treated_period_"),
~if_else(treated==1, .x, 0L)
)
)
data_st
})
logoutput_datasize(data_seqtrialcox)
install.packages("survival")
install.packages("survival")
